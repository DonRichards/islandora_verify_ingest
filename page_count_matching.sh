#!/usr/bin/env bash

clear
cat << "EOF"


Islandora
 ____                     ____                  _      ___
|  _ \ __ _  __ _  ___   / ___|___  _   _ _ __ | |_   ( _ )
| |_) / _` |/ _` |/ _ \ | |   / _ \| | | | '_ \| __|  / _ \/\
|  __/ (_| | (_| |  __/ | |__| (_) | |_| | | | | |_  | (_>  <
|_|   \__,_|\__, |\___|  \____\___/ \__,_|_| |_|\__|  \___/\/
           |___/
 __  __       _       _     _
|  \/  | __ _| |_ ___| |__ (_)_ __   __ _
| |\/| |/ _` | __/ __| '_ \| | '_ \ / _` |
| |  | | (_| | || (__| | | | | | | | (_| |
|_|  |_|\__,_|\__\___|_| |_|_|_| |_|\__, |
                                    |___/


              Count how many books & pages are in a given directory.
              Count how many books & pages are in Solr for a given collection.
              Find the collection's book/pages on the filesystem.
              Verify everything matches including the MODS values for pages.
EOF

echo -e "\n\n"

# Set Variables of where to look
COLLECTION_NAME="$1"
FIND_PATTERN="$2"
DOMAIN="http://digital.lib.utk.edu"
SOLR_DOMAIN_AND_PORT="http://digital.lib.utk.edu:8080"
COLLECTION_URL="https://digital.lib.utk.edu/collections/islandora/object/collections%3A"

# Checking that a collection name was given
if [ "${COLLECTION_NAME}" == "--help" ] || [ "${COLLECTION_NAME}" == "-h" ] || [[ -z "$COLLECTION_NAME" ]] || [[ -z "${FIND_PATTERN}" ]]; then
    echo -e "\n\n\n\t\033[41m Error: Please enter in a directory of books or the 'find' pattern \033[0m\n\t    Find pattern requires double quotes around the path.\n\n\t  Examples: (with and without wildcards)\n\n\t   \033[38;5;2m$ ./page_count_matching.sh collection_name \"/absolute/path/to/books/lobsterBatch\033[41m*\033[0m\033[38;5;2m/delivery/book/\033[41m*\033[0m\033\033[0m\"\n\t   \033[38;5;2m$ ./page_count_matching.sh collection_name \"/absolute/path/to/books/lobsterBatch1/delivery/book/\"\033[0m\n\n\n"
    exit 1
fi

garbage_disposal() {
  echo -e "\tRemove log files generated by this script."
  rm -f mods_local_id_and_page_count.txt
  rm -f file_systems_local_id_and_page_count.txt
  rm -f books_pids_from_curl.txt
  rm -f book_page_pids_from_curl.txt
  rm -f images_on_file_system.txt
  rm -rf book_mods
  echo -e "\t\t\e[32mLog files removed.\033[0m\n\n"
}

(garbage_disposal)

if [ ! -d book_mods ]; then
  mkdir book_mods;
fi

# Making sure the collection is findable
echo -e "\tChecking if ${COLLECTION_URL}${COLLECTION_NAME} is reachable"
declare -i count=0

connect_to_collection(){
  # try up to five times before timing out.
  if [ $count -gt 5 ]; then
    echo -e "\t  Can not find \"\033[38;5;2m$COLLECTION_NAME\033[0m\"\n\tLook at the URL after \"collections%3A\" \n\t   ${COLLECTION_URL}\033[38;5;2mCOLLECTION-NAME\033[0m\ \n\n\n"
    exit 0
  fi

  status=$(curl -s --head "${COLLECTION_URL}${COLLECTION_NAME}" | head -n 1 | grep "HTTP/1.[01] [23]..")
  sleep 1
  if [[ -z $status ]]; then
    echo -e "$COLLECTION_URL${COLLECTION_NAME} has timed out, trying again. Retry $count out of 5"
    ((count++))
    sleep 1
    connect_to_collection
  else
    ((count++))
    echo -e "\t\t\e[32mCollection check complete\033[0m\n"
  fi
}

(connect_to_collection)

# Creating an index of pages in the given directory
echo -e "\n\tCounting pages on filesystem"
$(find ${FIND_PATTERN} -name '*' -exec file {} \; | grep -o -P '^.+: \w+ image' > images_on_file_system.txt) &
$(find ${FIND_PATTERN} -name '*' -exec file {} \; | grep -o -P '^.+: \w+ pdf' > pdfs_on_file_system.txt) &

# Count how many pages for each book by sorted by physical ID.
list=$(find ${FIND_PATTERN} -type d -exec sh -c 'echo "${0##*/} $(ls $0 | wc -l)" ' {} \;)
firstLine=`echo "${list}" | head -1`
[[ $firstLine =~ [^[:digit:]] ]] && list=$(echo "$list" | tail -n +2 )

printf '%b\n' "${list[@]}" > file_systems_local_id_and_page_count.txt
book_files_in_filesystem=($(wc -l < file_systems_local_id_and_page_count.txt))
echo -e "\t\t\e[32mFile system count complete\033[0m\n\n "

# Get the PIDs of books
echo -e "\n\tGetting PIDs of all of the books within $COLLECTION_NAME collection\n"
SOLR_PAGE_COUNT=$(curl -X GET --progress-bar "$SOLR_DOMAIN_AND_PORT/solr/collection1/select?q=PID%3A${COLLECTION_NAME}%5C%3A*&fq=%2BRELS_EXT_hasModel_uri_ss%3Ainfo%5C%3Afedora%2Fislandora%5C%3ApageCModel&sort=PID+asc&rows=0&fl=PID&wt=xml&indent=true" | sed -n '/numFound="/,/?.*"/p' | grep -o -E '[0-9]+' | head -1 | sed -e 's/^0\+//')
curl -X GET --progress-bar "$SOLR_DOMAIN_AND_PORT/solr/collection1/select?q=PID%3A${COLLECTION_NAME}%5C%3A*&fq=%2BRELS_EXT_hasModel_uri_ss%3Ainfo%5C%3Afedora%2Fislandora%5C%3ApageCModel&sort=PID+asc&rows=100000&fl=PID&wt=csv&indent=true" | tail -n +2 >> book_page_pids_from_curl.txt
page_pids_in_solr=($(wc -l < book_page_pids_from_curl.txt))
curl -X GET --progress-bar "$SOLR_DOMAIN_AND_PORT/solr/collection1/select?q=PID%3A${COLLECTION_NAME}%5C%3A*&fq=%2BRELS_EXT_hasModel_uri_s%3Ainfo%5C%3Afedora%2Fislandora%5C%3AbookCModel&sort=PID+asc&rows=100000&fl=PID&wt=csv" | tail -n +2 >> books_pids_from_curl.txt


declare -i book_pid_count=0
get_pids_of_books(){
  # try up to five times before timing out.
  if [ $book_pid_count -gt 5 ]; then
    echo -e "\t Getting PIDs failed \"\033[38;5;2m$COLLECTION_NAME\033[0m\"\n\tLook at the URL after \"collections%3A\" \n\t   ${COLLECTION_URL}\033[38;5;2mCOLLECTION-NAME\033[0m\ \n\n\n"
    exit 0
  fi
  book_files=($(< books_pids_from_curl.txt))
  sleep 1
  if [ ${#book_files[@]} -eq 0 ]; then
    echo -e "Book PIDS for $COLLECTION_URL${COLLECTION_NAME} has timed out, trying again. Retry $book_pid_count out of 5"
    ((book_pid_count++))
    sleep 1
    get_pids_of_books
  else
    echo -e "\n\t\t\e[32m Book PIDs Found!\033[0m\n\n"
  fi
}

(get_pids_of_books)
book_files=($(< books_pids_from_curl.txt))

# MODS download
echo -e "\tDownload all of the MODS files for the ${#book_files[@]} books (not pages)"
declare -i mods_download_count=0
pstr="[=======================================================================]"

for file in "${book_files[@]}"; do
  if [ ! "$file" == "PID" ]; then
    wget -q "$DOMAIN/collections/islandora/object/${file}/datastream/MODS/download" -O "book_mods/${file}.xml"
    pd=$(( $mods_download_count * 73 / ${#book_files[@]} ))
    printf "\r\t%3d.%1d%% %.${pd}s" $(( $mods_download_count * 100 / ${#book_files[@]} )) $(( ($mods_download_count * 1000 / ${#book_files[@]}) % 10 )) $pstr
    ((mods_download_count++))
  fi
done
echo -e "\r\t100% $pstr "
echo -e "\t\t\e[32m${#book_files[@]} book MODS downloaded for the $COLLECTION_NAME collection\033[0m"

# Going through each book MODS file downloaded it outputs the info to a file.
for file in book_mods/*.xml; do
  file_id=$(cat $file | egrep "<identifier type=\"local\">.*</identifier>" |sed -e "s/<identifier type=\"local\">\(.*\)<\/identifier>/\1/"|tr "|" " "|sed 's/^[[:space:]]*//')
  pages=$(cat $file | egrep "<extent>.*</extent>" |sed -e "s/<extent>\(.*\) pages<\/extent>/\1/"|sed -e "s/<extent>\(.*\) page<\/extent>/\1/"|tr "|" " "|sed 's/^[[:space:]]*//')
  echo "${file_id} ${pages}" >> mods_local_id_and_page_count.txt
done

echo -e "\n\n\n\tWaiting for the filesystem image count has completed."
wait
echo -e "\n\n\n\t\t\e[32mWaiting over.\033[0m"

echo -e "\n\tComparing Counts and storing the ones that don't match"
# Compare what the filesystem says it has for pages vs the MODS page count.
# array of IDs that had a count that differed from the system's file structure
stuff=$(comm -23 <(sort mods_local_id_and_page_count.txt) <(sort file_systems_local_id_and_page_count.txt) | cut -f1 -d" ")
wait
echo -e "\n\t\t\e[32mComparing complete.\033[0m\n\n"

if [[ -z "${stuff}" ]] || [ -n "${stuff}" ]; then
  echo -e "\t\e[91mFound some issues with these PIDS: mismatched page count.\033[0m\n\t\tCould be a false possitive if a PDF book is within the collection."

  # For each of the mismatched values output the PID.
  for f in "${stuff[@]}"; do
    grep -r $f book_mods | cut -f1 -d"." | cut -d/ -f2- | cut -d/ -f2-
  done
else
    echo -e "\t\e[32mEverthing Matches\033[0m"
fi

# Report what was found.
COUNT_OF_PAGES_ON_FS=($(wc -l < images_on_file_system.txt))
COUNT_OF_PDFS_ON_FS=($(wc -l < pdfs_on_file_system.txt))
echo -e "\n\n\n\t Books found on filesystem \t| Books found in Solr"
echo -e "\t $(find ${FIND_PATTERN} -type d | wc -l)    \t\t\t| ${#book_files[@]}"
echo -e "\n\n\n\t Pages found on filesystem \t| Pages found in Solr including PDFs \t| Solr Records expected Page Count including PDFs"
echo -e "\t $COUNT_OF_PAGES_ON_FS    \t\t\t| $page_pids_in_solr \t\t\t\t| $SOLR_PAGE_COUNT\n\n\n"
echo -e "\tSummary of files on filesystem"
find ${FIND_PATTERN} -type f | sed -e 's/.*\.//' | sort | uniq -c | sort -n | grep -Ei '(tiff|bmp|jpeg|jpg|png|gif|pdf|tif)$'
echo -e "\n\n"
# Decide to either keep or throw out the leftover files.
while true; do
    read -p "Throw aways the left-overs? [yn] " yn
    case $yn in
        [Yy]* ) (garbage_disposal); break;;
        [Nn]* ) exit;;
        * ) echo "Please answer yes or no.";;
    esac
done
echo -e "\n\n\n\n"
